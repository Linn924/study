# 有关前端性能优化资料总结

## 1、页面DOM节点太多，会出现什么问题？如何优化？

+ 资源压缩合并，减少 HTTP 请求
+ 非核心代码异步加载 --> 异步加载的方式 --> 异步加载的区别
+ 利用浏览器缓存 --> 缓存的分类 --> 缓存的原理
+ 使用 CDN （让网络快速到达缓存服务器，将资源请求下来，尤其是当页面首次打开时）
+ 预解析 DNS （当页面有多个域名时，域名预解析的效果是很明显的）

### 1. 资源压缩合并，减少 HTTP 请求

+ 一个资源就会发起一个 HTTP请求
+ 合并 CSS/JS
+ 合并小图片:可使用 CSS sprite、base64、logo、iconfont 等方式（Data URL 和 iconfont 都是使用了 base64 的方式，当图片体积小就可以将图片以 base64 形式保存到项目中，从而减少了 http 请求）
+ 那为什么要用 base64 保存图片而不使用二进制形式保存呢？因为二进制中有 ASCII 控制字符（某一控制功能的字符），在传输时需要进行转换，所以使用 Base64 字符串形式方式来存储图片，不过体积会大 1/3

### 2. 非核心代码异步加载 --> 异步加载的方式 --> 异步加载的区别

异步加载的三种方式：
+ 动态脚本加载：用一个 document.createElement('script') 来创建一个标签，再添加到 body 或者 head 中，总之就是加载到文档当中实现动态加载。*在加入的 script 标签中可通过以下两个属性的其中之一，实现异步加载
+ defer：在 HTML 解析完之后才会执行，如果是多个，按照加载的顺序依次执行
+ async：在 HTML 解析完之后立即执行，如果是多个，执行顺序与加载顺序无关，跟文件大小有关（如果某个 js 文件过大，那么会先加载更小的文件，如果两个文件都不大，就可能会按照加载顺序执行）
+ 如果放在 body 中，就不需要使用异步加载，会先渲染 DOM

### 3. 利用浏览器缓存 --> 缓存的分类 --> 缓存的原理

+ 缓存的存储方式:cookie、localStorage
+ 缓存分类:强缓存和协商缓存

### 4. 使用 CDN

### 5. 预解析 DNS

在页面中使用 a 标签，在一些高级浏览器中是默认打开了 DNS 解析，但是如果页面是 HTTPS 开头的，很多浏览器是默认关闭 DNS 解析
```
//强制打开 a 标签的 DNS 解析
<meta http-equiv="x-dns-prefetch-control" content="on">

//打开预解析的方法
<link rel="dns-prefetch" href="//host_name_to_prefetch.com">
```

## 2、前端优化的最佳实践

+ 使用 DocumentFragment 来进行复杂的 DOM 操作或者添加
    ```
    //创建一个文档碎片
    let frag = document.createDocumentFragment()
    //将元素添加到文档碎片中
    frag.appendChild('div')
    //操作元素
    //将文档碎片添加到真实的 DOM 中，此时只会添加所有子元素
    document.body.appendChild(frag)
    ```

+ 高频执行事件，使用函数防抖或者函数节流来降低函数执行的频率
+ 使用事件委托
+ 恰当使用 Data URL 代替图片 src
    + Data URL 就是将图片转换成 Base64 编码的字符串形式嵌入到 HTML 中
    + 应用场景
        + 当访问外部资源很麻烦或者受限时
        + 当图片是在服务端用程序动态生成，每个访问用户显示得都不同
        + 当图片的体积小，占用一个 HTTP 请求不值得时
    + 不适用的场景
        + Base64编码的数据体积通常是原数据的体积4/3，也就是Data URL形式的图片会比二进制格式的图片体积大1/3
        + Data URL形式的图片不会被浏览器缓存，这意味着每次访问这样页面时都被下载一次。这是一个使用效率方面的问题——尤其当这个图片被整个网站大量使用的时候。
+ 使用索引对象
    + 对象有利于查询某个具体信息，根据 key 能快速找到 value，所以可以将数组数据结构先转换成一个索引对象，然后再使用这个索引对象进行查询
+ 控制 DOM 节点数量
    ```
    //查看页面 DOM 节点的方式：
    document.getElementByTagName('*').length
    ```
    + DOM 节点过多的缺点是：任何需要遍历 DOM 节点的操作都会效率很低，即 JS 中 DOM 访问速度较慢。
    + 优化方式
        + 使用 before 和 after 伪元素
        + 按需加载：在可视区域再加载和呈现内容
        + 事件委托，不需要在多个子节点绑定事件
        + 使用 innerHTML 存储 Ajax 请求回的数据，尽量减少对 DOM 的操作
        + 批量增加 Dom 尽量使用修改 innerHTML 的方式而不是用 appendChild 的方式; 因为使用innerHTML 开销更小,速度更快,同时也更加内存安全
        + 注意:用 innerHTML 方式添加时,一定不要在循环中使用 innerHTML += 的方式添加,这样反而会使速度减慢; 而是应该中间用 array 缓存起来,循环结束后调用 xx.innerHTML = array.join(""); 的方式,或者至少保存到 string 中再插到 innerHTML 中


## 3、如何做前端性能监测

>[前端性能监测](https://www.jianshu.com/p/40a727480bca)

+ 前端性能监测主要关注以下几个方面：
    + 用户操作的响应时间
    + 系统的吞吐量（TPS）
    + 系统的硬件资源情况（CPU、硬盘、磁盘）
    + 网络资源占用情况
    + 请求/响应时间，涉及到：DNS 解析、请求的连接、TLS 的建立（SSL 的同类）、字节流的发送。
+ 可使用的前端性能监测工具
    + WebpageTest
    + YSlow
    + Lighthouse
