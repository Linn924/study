# 前端面试资料总结

1. new的过程发生了什么
>1. 构造函数在内存中创建了一个空的对象
>2. this指向创建的空对象
>3. 执行构造函数里面的代码，给空对象添加属性和方法
>4. 返回此对象

2. es6中的新特性
>+ 使用let和const声明变量
>+ 解构赋值
>+ 箭头函数
>+ 剩余参数
>+ 扩展运算符
>+ 新增方法
>+ 内置对象set

3. Https 的加密过程 (CA证书加密过程到服务端和客户端确定加密算法，到开始通信的过程) 
> [Https的加密过程博客详解](https://blog.csdn.net/qq_32998153/article/details/80022489)
>1. 浏览器使用Https的URL访问服务器，建立SSL链接。  
>2. 服务器接收到SSL链接后，发送非对称加密的公钥给浏览器。  
>3. 浏览器生成随机数，作为对称加密的密钥A。  
>4. 浏览器使用服务器返回的公钥对自己生成的对称加密密钥A进行加密，得到密钥B。  
>5. 浏览器将密钥B发送给服务器  
>6. 服务器使用自己的私钥对接收的密钥B进行解密，得到对称加密密钥A。  
>7. 浏览器和服务器之间使用密钥A作为对称加密密钥进行通信。   
>![https的加密过程](https://s1.ax1x.com/2020/10/19/0x9tRe.png) 

4. http状态码
    |    |  类别  |  分离描述  |
    |  :----  | :----  | :----  |
    | 1xx  | Informational（信息性状态码） | 信息，服务器收到请求，需要请求者继续执行操作 |
    | 2xx  | Success（成功状态码） | 成功，操作被成功接收并处理 |
    | 3xx  | Redirection（重定向） | 重定向，需要进一步的操作以完成请求 |
    | 4xx  | Client error（客户端错误） | 客户端错误，请求包含语法错误或无法完成请求 |
    | 5xx  | Server Error（服务器错误） | 服务器错误，服务器在处理请求的过程中发生了错误 |  
>301与302的区别：前者是永久移动，后者是临时移动（之后可能还会更改URL）  
>302与303的区别：后者明确表示客户端应当采用GET方式获取资源
>+ 200 OK：请求成功。一般用于GET与POST请求
>+ 204 No Content：无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档
>+ 206 Patial Content：部分内容。服务器成功处理了部分GET请求
>+ 301 Moved Permanently：永久移动。请求的资源已被永久的移动到新URL，返回信息会包括新的URI，浏览器会自动定向到新URL。今后任何新的请求都应使用新的URL代替
>+ 302 Found：临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URL
>+ 303 See Other：查看其它地址。与301类似。使用GET和POST请求查看
>+ 304 Not Modified：未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源
>+ 307 Temporary Redirect：临时重定向。与302类似。使用GET请求重定向
>+ 400 Bad Request：客户端请求的语法错误，服务器无法理解
>+ 401 Unauthorized：未经许可，需要通过HTTP认证
>+ 403 Forbidden：服务器理解请求客户端的请求，但是拒绝执行此请求
>+ 404 Not Found：服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面
>+ 500 Inter Server Error：服务器内部错误，无法完成请求
>+ 503 Server Unavailable：由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中

5. 浏览器的缓存机制以及强缓存和协商缓存
>1.[浏览器的缓存机制以及强缓存和协商缓存详解](https://blog.csdn.net/hhthwx/article/details/80152728)  
>2.浏览器的缓存机制：对于浏览器的缓存来讲，这些规则是在HTTP协议头部和HTML页面的Meta标签中定义的。分别从新鲜度和校验值两个维度来规定浏览器是否可以直接使用缓存中的副本，还是需要去源服务器获取新版本。  
>3.强缓存不与服务器发生交互，而协商缓存则需要需服务器发生交互。  
>4.普通刷新会启用弱缓存，忽略强缓存。只有在地址栏或收藏夹输入网址、通过链接引用资源等情况下，浏览器才会启用强缓存，这也是为什么有时候我们更新一张图片、一个js文件，页面内容依然是旧的，但是直接浏览器访问那个图片或文件，看到的内容却是新的。
>1. 什么是浏览器缓存：浏览器缓存就是把一个已经请求过的web资源（如html页面，图片，JS，数据）拷贝一份放在浏览器中。缓存会根据进来的请求保存输入内容的副本。当下一个请求到来的时候，如果是相同的URL，浏览器会根据缓存机制决定是直接使用副本响应访问请求还是向源服务器再次发起请求。
>2. 使用缓存的原因：减少网络带宽消耗；降低服务器压力；减少网络延迟
>3. 过期机制：指的是缓存副本的有效期。一个缓存的副本必须满足以下条件，浏览器会认为它是有效的，足够新的：1.含有完整的过期时间控制头信息（HTTP协议报头），并且仍在有效期内。2.浏览器已经使用过这个缓存的副本，并且会在一个会话中已经检查过新鲜度(即服务器上的资源是否发生改变)满足以上两种情况的一种，浏览器会直接从缓存中获取副本进行渲染。  
>4. 校验值（验证机制）：服务器返回资源的时候有时在控制头信息带上这个资源的实体标签Etag(Entity Tag),它可以用来作为浏览器再次请求过程中的校验标识，如果发现校验标识不匹配，说明资源已经被修改或者过期，浏览器需要重新获取资源内容。
>5. 强制缓存：用户发送的请求，直接从客户端缓存中获取，不发送请求到服务器，不与服务器发生交互行为。
>6. 协商缓存：用户发送请求，发送到服务器之后，由服务器判定是否从缓存中获取资源。两者共同点：客户端获取的数据最后都是熊客户端的缓存中取得。
   
6. css盒子模型（或者是优势)
>+ 标准盒模型 box-sizing:content-box(元素默认)；设置的宽度就等于内容的宽度；标签得实际宽度 = 设置的宽度 + border宽度 + padding的宽度
>+ 怪异盒模型 box-sizing:border-box；内容的宽度 = 设置的宽度 - border的宽度 - padding的宽度；标签得实际宽度 = 设置的宽度 

7. css水平垂直居中（不知道页面长宽的前提）
```
<div class="box"></div>

/* 1.定位和transform属性实现(父元素是body) */
.box{
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%,-50%);
    width: 200px;
    height: 200px;
    background-color: #1e90ff;
}

/* 2.定位和外边距 auto(父元素是body) */
.box{
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    margin: auto;
    width: 200px;
    height: 200px;
    background-color: #1e90ff;
}
```

8. css取消浮动
```
/* 第一种  clear:both; */
/*  
    .clear{
        clear:both;
    }
*/
/* 第二种 overflow: hidden; */
/*  
    .fahter{
        width: 400px;
        border: 1px solid deeppink;
        overflow: hidden;
    }
*/
/* 第三种 使用after伪元素清除浮动 */
/* 
    .clearfix::after{
        content: "";
        display: block;
        height: 0;
        clear:both;
        visibility: hidden;
    } 
*/
/* 第四种 使用before和after双伪元素清除浮动 display: table; 让块级标签实现行内效果，即浮动至同一横轴，并实现等高效果 */
/* 
    .clearfix:after,.clearfix:before{
        content: "";
        display: table;
    }
    .clearfix:after{
        clear: both;
    } 
*/

.fahter{
    width: 400px;
    border: 1px solid deeppink;
}
.big{
    width: 200px;
    height: 200px;
    background: darkorange;
    float: left;
}
.small{
    width: 120px;
    height: 120px;
    background: darkmagenta;
    float: left;
}
.footer{
    width: 900px;
    height: 100px;
    background: darkslateblue;
}

<!-- 第一种方法 -->
<!-- <div class="fahter">
    <div class="big">big</div>
    <div class="small">small</div>
    <div class="clear">额外标签法</div>
</div>
<div class="footer"></div> -->

<!-- 第二种方法 -->
<!-- <div class="fahter">
    <div class="big">big</div>
    <div class="small">small</div>
</div>
<div class="footer"></div> -->

<!-- 第三种方法 -->
<!-- <div class="fahter clearfix">
    <div class="big">big</div>
    <div class="small">small</div>
</div>
<div class="footer"></div> -->

<!-- 第四种方法 -->
<div class="fahter clearfix">
    <div class="big">big</div>
    <div class="small">small</div>
</div>
<div class="footer"></div>

```

9. flex布局  
>默认情况下 主轴水平向右 侧轴水平向下
>+ flex-direction：设置主轴的方向
>+ justify-content：设置主轴上的子元素排列方式
>+ flex-wrap：设置子元素是否换行
>+ align-content：设置侧轴上的子元素的排列方式（多行）
>+ align-items：设置侧轴上的子元素排列方式（单行）
>+ flex-flow：复合属性，相当于同时设置了 flex-direction 和 flex-wrap
>+ flex 属性定义子项目分配剩余空间，用flex来表示占多少份数.子元素不给宽高 那么flex的剩余空间就是整个父元素的宽高
>+ align-self 控制子项自己在侧轴上的排列方式
>+ order 属性定义项目的排列顺序

10. js继承
>[7种继承方法](http://www.linncode.cn:9547/article?inherit.md)
>+ 原型链继承
>+ 构造继承
>+ 实例继承
>+ 拷贝继承
>+ 组合继承
>+ 寄生组合继承
>+ Class 继承
```
//原型链继承
function SuperType() {
    this.property = true; 
} 
SuperType.prototype.getSuperValue = function() { 
    return this.property; 
}; 
function SubType() { 
    this.subproperty = false; 
} 
// 继承 SuperType 
SubType.prototype = new SuperType(); 
SubType.prototype.getSubValue = function () {
    return this.subproperty; 
}; 
let instance = new SubType(); 
console.log(instance.getSuperValue()); // true

//寄生组合继承（继承的最佳模式）
function inheritPrototype(subType, superType) { 
    let prototype = object(superType.prototype); // 创建对象
    prototype.constructor = subType; // 增强对象 
    subType.prototype = prototype; // 赋值对象
}
function SuperType(name) { 
    this.name = name; 
    this.colors = ["red", "blue", "green"]; 
} 
SuperType.prototype.sayName = function() { 
    console.log(this.name); 
}; 
function SubType(name, age) { 
    SuperType.call(this, name);
    this.age = age; 
} 
inheritPrototype(SubType, SuperType); 
SubType.prototype.sayAge = function() { 
    console.log(this.age); 
};
//类继承
class Father {
    constructor(x, y) {
        this.x = x
        this.y = y
    }
    sum() {
        console.log(this.x + this.y)
    }
}

class Son extends Father {
    constructor(x,y) {
        super(x,y) //调用了父类中的构造函数
    }
}

var son = new Son(1,2)
son.sum()
```

11. apply call bind的区别
>+ call():调用函数；改变函数内this的指向；分别接受参数；常用来实现继承
>+ apply():调用函数；改变函数内this的指向；接受数组形式的参数；求数组最大值
>+ bind():不会调用原来的函数；改变函数内this的指向；返回的是原函数改变this之后产生的新函数；分别接受参数；

12. promise是什么？有哪三种状态
>Promise 对象用于表示一个异步操作的最终完成 (或失败)及其结果值。  
>Promise有三种状态 待定、已兑现、已拒绝（已兑现和已拒绝都称为已敲定）   
>+ 待定（pending）: 初始状态，既没有被兑现，也没有被拒绝。
>+ 已兑现（fulfilled）: 意味着操作成功完成。
>+ 已拒绝（rejected）: 意味着操作失败。
>promise的常见方法
>+ Promise.all(iterable)：返回一个新的promise对象，该promise对象在iterable参数对象里所有的promise对象都成功的时候才会触发成功，一旦有任何一个iterable里面的promise对象失败则立即触发该promise对象的失败。这个新的promise对象在触发成功状态以后，会把一个包含iterable里所有promise返回值的数组作为成功回调的返回值，顺序跟iterable的顺序保持一致；如果这个新的promise对象触发了失败状态，它会把iterable里第一个触发失败的promise对象的错误信息作为它的失败错误信息。Promise.all方法常被用于处理多个promise对象的状态集合。
>+ Promise.any(iterable)：接收一个Promise对象的集合，当其中的一个 promise 成功，就返回那个成功的promise的值。
>+ Promise.allSettled(iterable)：等到所有promises都已敲定（settled）（每个promise都已兑现（fulfilled）或已拒绝（rejected））。返回一个promise，该promise在所有promise完成后完成。并带有一个对象数组，每个对象对应每个promise的结果。
>+ Promise.reject(reason)：返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法
>+ Promise.resolve(value)：返回一个状态由给定value决定的Promise对象。如果该值是thenable(即，带有then方法的对象)，返回的Promise对象的最终状态由then方法执行决定；否则的话(该value为空，基本类型或者不带then方法的对象),返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。通常而言，如果您不知道一个值是否是Promise对象，使用Promise.resolve(value) 来返回一个Promise对象,这样就能将该value以Promise对象形式使用。

13. 闭包、原理及场景
>[什么是闭包？闭包的工作原理、优缺点、使用场景和对页面的影响](https://www.jianshu.com/p/380fea4a563f)  
>闭包（closure）指有权访问另一个函数作用域中变量的函数。一个作用域可以访问另外一个函数的局部变量   
>闭包的主要作用: 延伸了变量的作用范围  
>闭包的原理：js的链式作用域。子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。  
>闭包的使用场景：采用函数引用方式的setTimeout调用；将函数关联到对象的实例方法；封装相关的功能集
```
//原生的setTimeout有一个缺陷，传递的函数不能带参数
function fn(param) {
    return function() {
        alert(param);
    }
}
var f = fn(1)
setTimeout(f, 1000);
```

14. 手写call()
```
/*
 * call方法思想：改变this指向，让新的对象可以执行这个方法
 * 实现思路：
 * 1、给新的对象添加一个函数（方法），并让this（也就是当前绑定的函数）指向这个函数
 * 2、执行这个函数
 * 3、执行完以后删除这个方法
 * 4、可以将执行结果返回
 */

var obj = {
    value: 1
}

function test(name, age) {
    console.log(arguments)
    console.log(name, age)
    console.log(this.value)
}

Function.prototype.myCall = function(obj) {
    //判断调用此方法的是否是函数 不是抛出错误
    if(typeof this != "function") throw new TypeError("Erorr")
    //通过扩展运算arguments获取传递的参数 去掉第一个参数
    let args = [...arguments].slice(1)
    //把调用此方法的函数 赋值 给新对象新创建的fn方法
    obj.fn = this
    //调用新对象的fn方法
    var result = obj.fn(...args)
    //删除此方法
    delete obj.fn
    //返回结果
    return result
}

test.myCall(obj,"simon",20)
```

15. 手写前序遍历二叉树
>[前序遍历二叉树](https://www.php.cn/js-tutorial-407488.html)
```
function BinarySearchTree () {

    //创建二叉树类
    var Node = function(key) {
        this.key = key
        this.left = null
        this.right = null
    }
    var root = null

    //插入节点
    this.insert = function(key) {
        var newNode = new Node(key)
        if(root === null) {
            root = newNode
        } else {
            insertNode(root, newNode)
        }
    }

    var insertNode = function(node, newNode) {
        if (newNode.key <= node.key) {
            if (node.left === null) {
                node.left = newNode
            }else {
                insertNode(node.left, newNode)
            }
        }else {
            if (node.right === null) {
                node.right = newNode
            }else {
                insertNode(node.right, newNode)
            }
        }
    }

    //实现中序遍历
    this.inOrderTraverse = function() {
        inOrderTraverseNode(root)
    }
    var inOrderTraverseNode = function(node) {
        if (node !== null) {
            inOrderTraverseNode(node.left)
            console.log(node.key)
            inOrderTraverseNode(node.right)
        }
    }

    // 实现先序遍历
    this.preOrderTraverse = function() {
        preOrderTraverseNode(root)
    }
    var preOrderTraverseNode = function(node) {
        if (node !== null) {
            console.log(node.key)
            preOrderTraverseNode(node.left)
            preOrderTraverseNode(node.right)
        }
    }

    // 实现后序遍历
    this.postOrderTraverse = function() {
        postOrderTraverseNode(root)
    }
    var postOrderTraverseNode = function(node) {
        if (node !== null) {
            postOrderTraverseNode(node.left)
            postOrderTraverseNode(node.right)
            console.log(node.key)
        }
    }
}

var arr = [9,6,3,8,12,15]
var tree = new BinarySearchTree()
arr.map(item => {tree.insert(item)})

console.log("中序遍历")
tree.inOrderTraverse()
console.log("前序遍历")
tree.preOrderTraverse()
console.log("后序遍历")
tree.postOrderTraverse()

```

16. 手写快速排序
```
var quicksort = function(arr){
    if(!arr instanceof Array || arr.length <=1 ){
        return arr
    }

    let pivotIndex = Math.floor(arr.length / 2)
    let pivot = arr.splice(pivotIndex,1)[0]

    let left = []
    let right = []
    for(let i = 0;i < arr.length;i++){
        if(arr[i] < pivot){
            left.push(arr[i])
        }else{
            right.push(arr[i])
        }
    }
    return quicksort(left).concat([pivot],quicksort(right))
}

var array = [8,7,0,7,5,2,5,3,1]
quicksort(array)
```

17. 函数作用域和块级作用域
>[函数作用域和块级作用域](https://blog.csdn.net/little_little0_0/article/details/79675451)  
>+ 函数作用域：变量在定义的环境中以及嵌套的子函数中处处可见；
>+ 块级作用域：变量在离开定义的块级代码后立即被回收。

18. js事件流
>[对JS事件流的深入理解](https://zhuanlan.zhihu.com/p/114276880)  
>事件流描述的就是从页面中接收事件的顺序
>+ 事件冒泡
>+ 事件捕获

18. 三栏布局
>[三栏布局](http://www.linncode.cn:9547/article?threeColumns.md)

19. 两栏自适应
>[两栏自适应](http://www.linncode.cn:9547/article?twoColumns.md)

20. 浏览器从发送请求到渲染出页面的整个过程
>[从输入URL到页面展示到底发生了什么](https://blog.csdn.net/xiamiflying/article/details/81477539)  
>[浏览器从发送请求到渲染出页面的整个过程](http://www.linncode.cn:9547/article?interview.md)