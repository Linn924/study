# 前端面试资料总结

1. new的过程发生了什么
>1. 构造函数在内存中创建了一个空的对象
>2. this指向创建的空对象
>3. 执行构造函数里面的代码，给空对象添加属性和方法
>4. 返回此对象

2. es6中的新特性
>+ 使用let和const声明变量
>+ 解构赋值
>+ 箭头函数
>+ 剩余参数
>+ 扩展运算符
>+ 新增方法
>+ 内置对象set

3. Https 的加密过程 (CA证书加密过程到服务端和客户端确定加密算法，到开始通信的过程) 
> [Https的加密过程博客详解](https://blog.csdn.net/qq_32998153/article/details/80022489)
>1. 浏览器使用Https的URL访问服务器，建立SSL链接。  
>2. 服务器接收到SSL链接后，发送非对称加密的公钥给浏览器。  
>3. 浏览器生成随机数，作为对称加密的密钥A。  
>4. 浏览器使用服务器返回的公钥对自己生成的对称加密密钥A进行加密，得到密钥B。  
>5. 浏览器将密钥B发送给服务器  
>6. 服务器使用自己的私钥对接收的密钥B进行解密，得到对称加密密钥A。  
>7. 浏览器和服务器之间使用密钥A作为对称加密密钥进行通信。   
>![https的加密过程](https://s1.ax1x.com/2020/10/19/0x9tRe.png) 

4. http状态码
    |    |  类别  |  分离描述  |
    |  :----  | :----  | :----  |
    | 1xx  | Informational（信息性状态码） | 信息，服务器收到请求，需要请求者继续执行操作 |
    | 2xx  | Success（成功状态码） | 成功，操作被成功接收并处理 |
    | 3xx  | Redirection（重定向） | 重定向，需要进一步的操作以完成请求 |
    | 4xx  | Client error（客户端错误） | 客户端错误，请求包含语法错误或无法完成请求 |
    | 5xx  | Server Error（服务器错误） | 服务器错误，服务器在处理请求的过程中发生了错误 |  
>301与302的区别：前者是永久移动，后者是临时移动（之后可能还会更改URL）  
>302与303的区别：后者明确表示客户端应当采用GET方式获取资源
>+ 200 OK：请求成功。一般用于GET与POST请求
>+ 204 No Content：无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档
>+ 206 Patial Content：部分内容。服务器成功处理了部分GET请求
>+ 301 Moved Permanently：永久移动。请求的资源已被永久的移动到新URL，返回信息会包括新的URI，浏览器会自动定向到新URL。今后任何新的请求都应使用新的URL代替
>+ 302 Found：临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URL
>+ 303 See Other：查看其它地址。与301类似。使用GET和POST请求查看
>+ 304 Not Modified：未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源
>+ 307 Temporary Redirect：临时重定向。与302类似。使用GET请求重定向
>+ 400 Bad Request：客户端请求的语法错误，服务器无法理解
>+ 401 Unauthorized：未经许可，需要通过HTTP认证
>+ 403 Forbidden：服务器理解请求客户端的请求，但是拒绝执行此请求
>+ 404 Not Found：服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面
>+ 500 Inter Server Error：服务器内部错误，无法完成请求
>+ 503 Server Unavailable：由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中

5. 浏览器的缓存机制以及强缓存和协商缓存
>1.[浏览器的缓存机制以及强缓存和协商缓存详解](https://blog.csdn.net/hhthwx/article/details/80152728)  
>2.浏览器的缓存机制：对于浏览器的缓存来讲，这些规则是在HTTP协议头部和HTML页面的Meta标签中定义的。分别从新鲜度和校验值两个维度来规定浏览器是否可以直接使用缓存中的副本，还是需要去源服务器获取新版本。  
>3.强缓存不与服务器发生交互，而协商缓存则需要需服务器发生交互。  
>4.普通刷新会启用弱缓存，忽略强缓存。只有在地址栏或收藏夹输入网址、通过链接引用资源等情况下，浏览器才会启用强缓存，这也是为什么有时候我们更新一张图片、一个js文件，页面内容依然是旧的，但是直接浏览器访问那个图片或文件，看到的内容却是新的。
>1. 什么是浏览器缓存：浏览器缓存就是把一个已经请求过的web资源（如html页面，图片，JS，数据）拷贝一份放在浏览器中。缓存会根据进来的请求保存输入内容的副本。当下一个请求到来的时候，如果是相同的URL，浏览器会根据缓存机制决定是直接使用副本响应访问请求还是向源服务器再次发起请求。
>2. 使用缓存的原因：减少网络带宽消耗；降低服务器压力；减少网络延迟
>3. 过期机制：指的是缓存副本的有效期。一个缓存的副本必须满足以下条件，浏览器会认为它是有效的，足够新的：1.含有完整的过期时间控制头信息（HTTP协议报头），并且仍在有效期内。2.浏览器已经使用过这个缓存的副本，并且会在一个会话中已经检查过新鲜度(即服务器上的资源是否发生改变)满足以上两种情况的一种，浏览器会直接从缓存中获取副本进行渲染。  
>4. 校验值（验证机制）：服务器返回资源的时候有时在控制头信息带上这个资源的实体标签Etag(Entity Tag),它可以用来作为浏览器再次请求过程中的校验标识，如果发现校验标识不匹配，说明资源已经被修改或者过期，浏览器需要重新获取资源内容。
>5. 强制缓存：用户发送的请求，直接从客户端缓存中获取，不发送请求到服务器，不与服务器发生交互行为。
>6. 协商缓存：用户发送请求，发送到服务器之后，由服务器判定是否从缓存中获取资源。两者共同点：客户端获取的数据最后都是熊客户端的缓存中取得。
   
6. css盒子模型（或者是优势)
>+ 标准盒模型 box-sizing:content-box(元素默认)；设置的宽度就等于内容的宽度；标签得实际宽度 = 设置的宽度 + border宽度 + padding的宽度
>+ 怪异盒模型 box-sizing:border-box；内容的宽度 = 设置的宽度 - border的宽度 - padding的宽度；标签得实际宽度 = 设置的宽度 

7. css水平垂直居中（不知道页面长宽的前提）
```
<div class="box"></div>

/* 1.定位和transform属性实现(父元素是body) */
.box{
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%,-50%);
    width: 200px;
    height: 200px;
    background-color: #1e90ff;
}

/* 2.定位和外边距 auto(父元素是body) */
.box{
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    margin: auto;
    width: 200px;
    height: 200px;
    background-color: #1e90ff;
}
```

8. css取消浮动
```
/* 第一种  clear:both; */
/*  
    .clear{
        clear:both;
    }
*/
/* 第二种 overflow: hidden; */
/*  
    .fahter{
        width: 400px;
        border: 1px solid deeppink;
        overflow: hidden;
    }
*/
/* 第三种 使用after伪元素清除浮动 */
/* 
    .clearfix::after{
        content: "";
        display: block;
        height: 0;
        clear:both;
        visibility: hidden;
    } 
*/
/* 第四种 使用before和after双伪元素清除浮动 display: table; 让块级标签实现行内效果，即浮动至同一横轴，并实现等高效果 */
/* 
    .clearfix:after,.clearfix:before{
        content: "";
        display: table;
    }
    .clearfix:after{
        clear: both;
    } 
*/

.fahter{
    width: 400px;
    border: 1px solid deeppink;
}
.big{
    width: 200px;
    height: 200px;
    background: darkorange;
    float: left;
}
.small{
    width: 120px;
    height: 120px;
    background: darkmagenta;
    float: left;
}
.footer{
    width: 900px;
    height: 100px;
    background: darkslateblue;
}

<!-- 第一种方法 -->
<!-- <div class="fahter">
    <div class="big">big</div>
    <div class="small">small</div>
    <div class="clear">额外标签法</div>
</div>
<div class="footer"></div> -->

<!-- 第二种方法 -->
<!-- <div class="fahter">
    <div class="big">big</div>
    <div class="small">small</div>
</div>
<div class="footer"></div> -->

<!-- 第三种方法 -->
<!-- <div class="fahter clearfix">
    <div class="big">big</div>
    <div class="small">small</div>
</div>
<div class="footer"></div> -->

<!-- 第四种方法 -->
<div class="fahter clearfix">
    <div class="big">big</div>
    <div class="small">small</div>
</div>
<div class="footer"></div>

```

9. flex布局  
>默认情况下 主轴水平向右 侧轴水平向下
>+ flex-direction：设置主轴的方向
>+ justify-content：设置主轴上的子元素排列方式
>+ flex-wrap：设置子元素是否换行
>+ align-content：设置侧轴上的子元素的排列方式（多行）
>+ align-items：设置侧轴上的子元素排列方式（单行）
>+ flex-flow：复合属性，相当于同时设置了 flex-direction 和 flex-wrap
>+ flex 属性定义子项目分配剩余空间，用flex来表示占多少份数.子元素不给宽高 那么flex的剩余空间就是整个父元素的宽高
>+ align-self 控制子项自己在侧轴上的排列方式
>+ order 属性定义项目的排列顺序

10. js继承
>[7种继承方法](http://blog.linncode.cn/article?inherit.md)
>+ 原型链继承
>+ 构造继承
>+ 实例继承
>+ 拷贝继承
>+ 组合继承
>+ 寄生组合继承
>+ Class 继承
```
//原型链继承
function SuperType() {
    this.property = true; 
} 
SuperType.prototype.getSuperValue = function() { 
    return this.property; 
}; 
function SubType() { 
    this.subproperty = false; 
} 
// 继承 SuperType 
SubType.prototype = new SuperType(); 
SubType.prototype.getSubValue = function () {
    return this.subproperty; 
}; 
let instance = new SubType(); 
console.log(instance.getSuperValue()); // true

//寄生组合继承（继承的最佳模式）
function inheritPrototype(subType, superType) { 
    let prototype = object(superType.prototype); // 创建对象
    prototype.constructor = subType; // 增强对象 
    subType.prototype = prototype; // 赋值对象
}
function SuperType(name) { 
    this.name = name; 
    this.colors = ["red", "blue", "green"]; 
} 
SuperType.prototype.sayName = function() { 
    console.log(this.name); 
}; 
function SubType(name, age) { 
    SuperType.call(this, name);
    this.age = age; 
} 
inheritPrototype(SubType, SuperType); 
SubType.prototype.sayAge = function() { 
    console.log(this.age); 
};
//类继承
class Father {
    constructor(x, y) {
        this.x = x
        this.y = y
    }
    sum() {
        console.log(this.x + this.y)
    }
}

class Son extends Father {
    constructor(x,y) {
        super(x,y) //调用了父类中的构造函数
    }
}

var son = new Son(1,2)
son.sum()
```

11. apply call bind的区别
>+ call():调用函数；改变函数内this的指向；分别接受参数；常用来实现继承
>+ apply():调用函数；改变函数内this的指向；接受数组形式的参数；求数组最大值
>+ bind():不会调用原来的函数；改变函数内this的指向；返回的是原函数改变this之后产生的新函数；分别接受参数；

12. promise是什么？有哪三种状态
>[promise基本使用](https://es6.ruanyifeng.com/#docs/promise)  
>Promise 对象用于表示一个异步操作的最终完成 (或失败)及其结果值。  
>Promise有三种状态 待定、已兑现、已拒绝（已兑现和已拒绝都称为已敲定）   
>+ 待定（pending）: 初始状态，既没有被兑现，也没有被拒绝。
>+ 已兑现（fulfilled）: 意味着操作成功完成。
>+ 已拒绝（rejected）: 意味着操作失败。
>promise的常见方法
>+ Promise.all(iterable)：返回一个新的promise对象，该promise对象在iterable参数对象里所有的promise对象都成功的时候才会触发成功，一旦有任何一个iterable里面的promise对象失败则立即触发该promise对象的失败。这个新的promise对象在触发成功状态以后，会把一个包含iterable里所有promise返回值的数组作为成功回调的返回值，顺序跟iterable的顺序保持一致；如果这个新的promise对象触发了失败状态，它会把iterable里第一个触发失败的promise对象的错误信息作为它的失败错误信息。Promise.all方法常被用于处理多个promise对象的状态集合。
>+ Promise.any(iterable)：接收一个Promise对象的集合，当其中的一个 promise 成功，就返回那个成功的promise的值。
>+ Promise.allSettled(iterable)：等到所有promises都已敲定（settled）（每个promise都已兑现（fulfilled）或已拒绝（rejected））。返回一个promise，该promise在所有promise完成后完成。并带有一个对象数组，每个对象对应每个promise的结果。
>+ Promise.reject(reason)：返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法
>+ Promise.resolve(value)：返回一个状态由给定value决定的Promise对象。如果该值是thenable(即，带有then方法的对象)，返回的Promise对象的最终状态由then方法执行决定；否则的话(该value为空，基本类型或者不带then方法的对象),返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。通常而言，如果您不知道一个值是否是Promise对象，使用Promise.resolve(value) 来返回一个Promise对象,这样就能将该value以Promise对象形式使用。

1.  闭包、原理及场景
>[什么是闭包？闭包的工作原理、优缺点、使用场景和对页面的影响](https://www.jianshu.com/p/380fea4a563f)  
>闭包（closure）指有权访问另一个函数作用域中变量的函数。一个作用域可以访问另外一个函数的局部变量   
>闭包的主要作用: 延伸了变量的作用范围  
>闭包的原理：js的链式作用域。子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。  
>闭包的使用场景：采用函数引用方式的setTimeout调用；将函数关联到对象的实例方法；封装相关的功能集
```
//原生的setTimeout有一个缺陷，传递的函数不能带参数
function fn(param) {
    return function() {
        alert(param);
    }
}
var f = fn(1)
setTimeout(f, 1000);
```

14. 手写call()
```
/*
 * call方法思想：改变this指向，让新的对象可以执行这个方法
 * 实现思路：
 * 1、给新的对象添加一个函数（方法），并让this（也就是当前绑定的函数）指向这个函数
 * 2、执行这个函数
 * 3、执行完以后删除这个方法
 * 4、可以将执行结果返回
 */

var obj = {
    value: 1
}

function test(name, age) {
    console.log(arguments)
    console.log(name, age)
    console.log(this.value)
}

Function.prototype.myCall = function(obj) {
    //判断调用此方法的是否是函数 不是抛出错误
    if(typeof this != "function") throw new TypeError("Erorr")
    //通过扩展运算arguments获取传递的参数 去掉第一个参数
    let args = [...arguments].slice(1)
    //把调用此方法的函数 赋值 给新对象新创建的fn方法
    obj.fn = this
    //调用新对象的fn方法
    var result = obj.fn(...args)
    //删除此方法
    delete obj.fn
    //返回结果
    return result
}

test.myCall(obj,"simon",20)
```

15. 手写前序遍历二叉树
>[前序遍历二叉树](https://www.php.cn/js-tutorial-407488.html)
```
function BinarySearchTree () {

    //创建二叉树类
    var Node = function(key) {
        this.key = key
        this.left = null
        this.right = null
    }
    var root = null

    //插入节点
    this.insert = function(key) {
        var newNode = new Node(key)
        if(root === null) {
            root = newNode
        } else {
            insertNode(root, newNode)
        }
    }

    var insertNode = function(node, newNode) {
        if (newNode.key <= node.key) {
            if (node.left === null) {
                node.left = newNode
            }else {
                insertNode(node.left, newNode)
            }
        }else {
            if (node.right === null) {
                node.right = newNode
            }else {
                insertNode(node.right, newNode)
            }
        }
    }

    //实现中序遍历
    this.inOrderTraverse = function() {
        inOrderTraverseNode(root)
    }
    var inOrderTraverseNode = function(node) {
        if (node !== null) {
            inOrderTraverseNode(node.left)
            console.log(node.key)
            inOrderTraverseNode(node.right)
        }
    }

    // 实现先序遍历
    this.preOrderTraverse = function() {
        preOrderTraverseNode(root)
    }
    var preOrderTraverseNode = function(node) {
        if (node !== null) {
            console.log(node.key)
            preOrderTraverseNode(node.left)
            preOrderTraverseNode(node.right)
        }
    }

    // 实现后序遍历
    this.postOrderTraverse = function() {
        postOrderTraverseNode(root)
    }
    var postOrderTraverseNode = function(node) {
        if (node !== null) {
            postOrderTraverseNode(node.left)
            postOrderTraverseNode(node.right)
            console.log(node.key)
        }
    }
}

var arr = [9,6,3,8,12,15]
var tree = new BinarySearchTree()
arr.map(item => {tree.insert(item)})

console.log("中序遍历")
tree.inOrderTraverse()
console.log("前序遍历")
tree.preOrderTraverse()
console.log("后序遍历")
tree.postOrderTraverse()

```

16. 手写快速排序
```
var quicksort = function(arr){
    if(!arr instanceof Array || arr.length <=1 ){
        return arr
    }

    let pivotIndex = Math.floor(arr.length / 2)
    let pivot = arr.splice(pivotIndex,1)[0]

    let left = []
    let right = []
    for(let i = 0;i < arr.length;i++){
        if(arr[i] < pivot){
            left.push(arr[i])
        }else{
            right.push(arr[i])
        }
    }
    return quicksort(left).concat([pivot],quicksort(right))
}

var array = [8,7,0,7,5,2,5,3,1]
quicksort(array)
```

17. 函数作用域和块级作用域
>[函数作用域和块级作用域](https://blog.csdn.net/little_little0_0/article/details/79675451)  
>+ 函数作用域：变量在定义的环境中以及嵌套的子函数中处处可见；
>+ 块级作用域：变量在离开定义的块级代码后立即被回收。

18. js事件流
>[对JS事件流的深入理解](https://zhuanlan.zhihu.com/p/114276880)  
>事件流描述的就是从页面中接收事件的顺序
>+ 事件冒泡(事件代理、事件委托)
>+ 事件捕获
>1. 如何先执行冒泡事件，再执行捕获事件  
>给被点击的dom元素添加两个点击事件，第一个是冒泡，第二是是捕获。点击的必须是此对象，根据代码顺序先执行冒泡在执行捕获

18. 三栏布局
>[三栏布局](http://blog.linncode.cn/article?threeColumns.md)

19. 两栏自适应
>[两栏自适应](http://blog.linncode.cn/article?twoColumns.md)

20. 浏览器从发送请求到渲染出页面的整个过程  
>[浏览器从发送请求到渲染出页面的整个过程](http://blog.linncode.cn/article?interview.md)

21. cookies、session、sessionStorage、localStorage
>[cookies、session、sessionStorage、localStorage](http://blog.linncode.cn/article?cookie.md)

22. restful api
>[restful api](https://www.jianshu.com/p/2a1eb087f224)

23. GET POST的区别
>[GET POST的区别](https://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html)  
最大的区别就是语义的区别：Get是向服务器发索取数据的一种请求，而Post是向服务器提交数据的一种请求

24. 常见的请求头 content-type 能设置什么值
>[请求头Content-Type常见的几种值](https://blog.csdn.net/weixin_37909391/article/details/81218572)  
>1.application/x-www-form-urlencoded  
浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。首先，Content-Type 被指定为 application/x-www-form-urlencoded；其次，提交的数据按照 key1=val1&key2=val2 的方式进行编码，key 和 val 会进行了 URL 转码。大部分服务端语言都对这种方式有很好的支持。  
>2. multipart/form-data  
这也是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，就要让 form 的 enctype 等于这个值。  
>3. application/json
application/json告诉服务端消息主体是序列化后的 JSON 字符串。由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify，服务端语言也都有处理 JSON 的函数，使用 JSON 不会遇上什么麻烦。JSON 格式支持比键值对复杂得多的结构化数据，这一点也很有用。

25. 跨域方法
>[跨域方法](https://www.cnblogs.com/suihang/p/13620361.html)

26. 同源政策
>[浏览器同源政策及其规避方法](https://ruanyifeng.com/blog/2016/04/same-origin-policy.html)

27. 防抖和节流
>[防抖和节流](https://juejin.im/post/6844904185117278215)

28. es6是什么？为什么使用es6？
>ES6就是ECMAScript6是新版本JavaScript语言的标准

29. typeof
```
console.log(typeof null) //object
console.log(typeof undefined) //undefined
console.log(typeof NaN) //number
console.log(typeof []) //object
```
30. 栈和队列的区别？如何用两个栈实现一个队列？
>栈遵循“后进先出（LIFO）”的原则，即只能在该线性表的一头进行数据的插入和删除，该位置称为“栈顶”,而另外一头称为“栈底”;  
>队列遵循“先进先出（FIFO）”的原则，即只能在队列的尾部插入元素，头部删除元素。

```
//实现思路：假设两个栈分别为 stack1 和 stack2，将stack1用于入队操作，将stack2用于出队操作。当stack2为空时，将stack1的元素弹出并推入stack2中。每次出队操作，就是对stack2的弹出操作。

let stack1 = [],stack2 = []

function add(node){
    stack1.push(node)
}

function remove(){
    if(stack1.length == 0 && stack2.length == 0) reutrn 

    if(stack2.length == 0){
        for(let i = stack1.length - 1; i>=0; i--){
            stack2.push(stack1.pop())
        }
    }
    return stack2.pop()
}
```
31. 造成内存泄漏的操作
>[JS哪些操作会造成内存泄露](https://blog.csdn.net/michael8512/article/details/77888000)   
>js的回收机制：找出不在使用的变量。释放其占用的内存，此过程不是实时的，会按照固定的时间间隔、周期性的执行。通常使用两种方法：标记清除和引用计数  
>+ 标记清除  
当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。
```
function test(){
  var a=10;//被标记，进入环境
  var b=20;//被标记，进入环境
}
test();//执行完毕之后a、b又被标记离开环境，被回收
```
>+ 引用计数  
引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值（function object array）赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。
```
function test(){
  var a={};//a的引用次数为0
  var b=a;//a的引用次数加1，为1
  var c=a;//a的引用次数加1，为2
  var b={};//a的引用次数减1，为1
}
```
>哪些操作会造成内存泄漏  
>+ 意外的全局变量引起的内存泄露
```
function leak(){
  leak="xxx";//leak成为一个全局变量，不会被回收
}
```
>+ 闭包引起的内存泄漏
```
function bindEvent(){
  var obj=document.createElement("XXX");
  obj.οnclick=function(){
    //Even if it's a empty function
  }
}
```
>闭包可以维持函数内局部变量，使其得不到释放。 上例定义事件回调时，由于是函数内定义函数，并且内部函数--事件回调的引用外暴了，形成了闭包。
解决之道，将事件处理函数定义在外部，解除闭包,或者在定义事件处理函数的外部函数中，删除对dom的引用。
```
//将事件处理函数定义在外部
function onclickHandler(){
  //do something
}
function bindEvent(){
  var obj=document.createElement("XXX");
  obj.οnclick=onclickHandler;
}

//在定义事件处理函数的外部函数中，删除对dom的引用
function bindEvent(){
  var obj=document.createElement("XXX");
  obj.οnclick=function(){
    //Even if it's a empty function
  }
  obj=null;
}
```

>+ 没有清理的DOM元素引用
```
var elements={
    button: document.getElementById("button"),
    image: document.getElementById("image"),
    text: document.getElementById("text")
};
function doStuff(){
    image.src="http://some.url/image";
    button.click():
    console.log(text.innerHTML)
}
function removeButton(){
    document.body.removeChild(document.getElementById('button'))
}
```

>+ 被遗忘的定时器或者回调
```
var someResouce=getData();
setInterval(function(){
    var node=document.getElementById('Node');
    if(node){
        node.innerHTML=JSON.stringify(someResouce)
    }
},1000)
```
>这样的代码很常见, 如果 id 为 Node 的元素从 DOM 中移除, 该定时器仍会存在, 同时, 因为回调函数中包含对 someResource 的引用, 定时器外面的 someResource 也不会被释放。

>+ 子元素存在引起的内存泄露

32. 事件循环。什么是宏任务和微任务？
>[深入理解JavaScript的事件循环(Event Loop)](https://blog.csdn.net/tzllxya/article/details/92674042)

33. css实现任意角度扇形
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>扇形</title>
</head>
<style>
    /* 扇形制作原理，底部一个纯色原形，里面2个相同颜色的半圆，可以是白色,内部半圆按一定角度变化，就可以产生出扇形效果 */
    *{
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }
    .sector{ 
        position: relative;
        width: 200px; 
        height: 200px; 
        border-radius: 50%; 
        background-color: yellow;
    }
    .box1{
        position: absolute; 
        width: 200px; 
        height: 200px; 
        transform: rotate(-60deg); 
        /*clip属性用来绘制半圆，在clip的rect范围内的内容显示出来，使用clip属性，元素必须是absolute的 */
        clip: rect(0px,100px,200px,0px); 
        border-radius: 50%; 
        background-color: #fff;
    }
    .box2{
        position: absolute; 
        width: 200px; 
        height: 200px; 
        transform: rotate(60deg); 
        clip: rect(0px,100px,200px,0px);  
        border-radius: 50%; 
        background-color: #fff;
    }
</style>
<body>
    <div class="sector">
        <div class="box1"></div>
        <div class="box2"></div>
    </div>
</body>
</html>
```

34. less和sass作用和区别
>[LESS与SASS的区别](https://www.jianshu.com/p/e3f1fcbbccc3)   
> sass和less都是css的预编译处理语言，他们引入了mixins，参数，嵌套规则，运算，颜色，名字空间，作用域，JavaScript赋值等,加快了css开发效率,当然这两者都可以配合gulp和grunt等前端构建工具使用  
>sass和less主要区别:在于实现方式:less是基于JavaScript的在客户端处理 所以安装的时候用npm，sass是基于ruby所以在服务器处理。

35. 深浅拷贝区别，手写深拷贝。
>浅拷贝只是拷贝一层, 更深层次对象级别的只拷贝引用.  
>深拷贝拷贝多层, 每一级别的数据都会拷贝.
```
function deepCopy(newobj, oldobj) {
    for (var k in oldobj) {
        var item = oldobj[k] //属性值为oldobj[k]
        if (item instanceof Array) { //属性值为数组
            newobj[k] = []
            deepCopy(newobj[k], item) 
        } else if (item instanceof Object) { //属性值为对象
            newobj[k] = {}
            deepCopy(newobj[k], item)
        } else { //属性值为简单数据类型
            newobj[k] = item
        }
    }
}
```

36. 手写dfs、bfs算法，概述用递归实现bfs、循环实现dfs。 
>[深度优先遍历(DFS)和广度优先遍历(BFS)](https://www.php.cn/js-tutorial-416671.html)   
>DFS(深度优先搜索):以纵向的维度对dom树进行遍历，从一个dom节点开始，一直遍历其子节点，直到它的所有子节点都被遍历完毕之后在遍历它的兄弟节点。   
>BFS(广度优先搜索):以横向的维度对dom树进行遍历，从该节点的第一个子节点开始，遍历其所有的兄弟节点，再遍历第一个节点的子节点，完成该遍历之后，暂时不深入，开始遍历其兄弟节点的子节点。  

![DFS](https://s1.ax1x.com/2020/10/27/BQumRS.png)
```
//深度优先搜索(DFS)
function deepFirstSearch(node,nodeList) { 
    if (node) {   
        nodeList.push(node)
        var children = node.children  
        for (var i = 0; i < children.length; i++)
        //每次递归的时候将 需要遍历的节点 和 节点所存储的数组传下去
        deepFirstSearch(children[i],nodeList);  
    }   
    return nodeList
}
```
![BFS](https://s1.ax1x.com/2020/10/27/BQunxg.png)
```
//广度优先搜索(BFS)
//递归版本的BFS由于层级太深，会导致堆栈溢出：Maximum call stack size exceeded，但遍历的顺序依旧没有问题，可以在遍历过程中进行操作，不返回遍历数组即可。
function breadthFirstSearch(node) {
    var nodes = []
    var i = 0
    if (!(node == null)) {
        nodes.push(node)
        breadthFirstSearch(node.nextElementSibling)
        node = nodes[i++]
        breadthFirstSearch(node.firstElementChild)
    }
    return nodes
}
```

37. 基本类型和引用类型的区别
>[JS基本数据类型和引用数据类型的区别](https://www.jianshu.com/p/a32fe1c964c1)

>数据类型
>+ ECMAScript变量包含两种不同类型的值：基本类型值、引用类型值；  
>+ 基本类型值：指的是保存在栈内存中的简单数据段；
>+ 引用类型值：指的是那些保存在堆内存中的对象，意思是，变量中保存的实际上只是一个指针，这个指针指向内存堆中实际的值；

>两种访问方式
>+ 基本类型值：按值访问，操作的是他们实际保存的值；
>+ 引用类型值：按引用访问，当查询时，我们需要先从栈中读取内存地址，然后再顺藤摸瓜地找到保存在堆内存中的值；

>两种类型复制
>+ 基本类型变量的复制：从一个变量向一个变量复制时，会在栈中创建一个新值，然后把值复制到为新变量分配的位置上，改变源数据不会影响到新的变量（互不干涉）；
>+ 引用类型变量的复制：复制的是存储在栈中的指针，将指针复制到栈中为新变量分配的空间中，而这个指针副本和原指针执行存储在堆中的同一个对象，复制操作结束后，两个变量实际上将引用同一个对象；因此改变其中的一个，将影响另一个；

38. var与let、const的区别
>+ var关键字声明的变量会挂载在window上，而let和const关键字声明的变量不会挂载到window上
>+ var关键字声明的变量存在变量提升，let和const关键字声明的变量不存在变量提升
>+ 在一个大括号中，使用let、const关键字声明的变量才具有块级作用域 var关键字是不具备这个特点的
>+ 同一作用域下let和const不能声明同名变量，而var可以
>+ let关键字声明的变量具有暂时性死区特性
>+ const关键字声明的变量是常量;一旦声明必须赋值;声明后不能再修改;如果声明的是复合类型数据，可以修改其属性

39. null和undefined的区别
>[null和undefined的区别](http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html)
>区别
>+ null 表示一个值被定义了，定义为“空值”；
>+ undefined 表示根本不存在定义。

>null典型用法
>+ 作为函数的参数，表示该函数的参数不是对象。
>+ 作为对象原型链的终点。

>undefined典型用法
>+ 变量被声明了，但没有赋值时，就等于undefined。
>+ 调用函数时，应该提供的参数没有提供，该参数等于undefined。
>+ 对象没有赋值的属性，该属性的值为undefined。
>+ 函数没有返回值时，默认返回undefined。

40. js原型链
>[js原型链](https://www.jianshu.com/p/08c07a953fa0)
>每个对象都可以有一个原型_proto_，这个原型还可以有它自己的原型，以此类推，形成一个原型链。查找特定属性的时候，我们先去这个对象里去找，如果没有的话就去它的原型对象里面去，如果还是没有的话再去向原型对象的原型对象里去寻找。这个操作被委托在整个原型链上，这个就是我们说的原型链了。  
>instanceof是判断实例对象的__proto__和生成该实例的构造函数的prototype是不是引用的同一个地址。
![原型链](https://s1.ax1x.com/2020/10/27/BlEEtS.png)

41. 设置文字大小为6px
>[浏览器最小只能识别12px](Chrome谷歌浏览器下不支持css字体小于12px的解决办法)
```
<span>simon</span>

 span{
    display: block;
    font-size: 12px; 
    transform: scale(0.5);
}
```

42. css优先级
>[css样式优先级](https://www.runoob.com/w3cnote/css-style-priority.html)

>+ 1.最近的祖先样式比其他祖先样式优先级高
```
<!-- 类名为 son 的 div 的 color 为 blue -->
<div style="color: red">
    <div style="color: blue">
        <div class="son"></div>
    </div>
</div>
```
>+ 2."直接样式"比"祖先样式"优先级高
```
<!-- 类名为 son 的 div 的 color 为 blue -->
<div style="color: red">
    <div class="son" style="color: blue"></div>
</div>
```
>+ 3.优先级关系：内联样式 > ID 选择器 > 类选择器 = 属性选择器 = 伪类选择器 > 标签选择器 = 伪元素选择器
```
<!-- color 为 black -->
<div class="content-class" id="content-id" style="color: black"></div>

#content-id {
    color: red;
}
.content-class {
    color: blue;
}
div {
    color: grey;
}
```
>+ 4.计算选择符中 ID 选择器的个数（a），计算选择符中类选择器、属性选择器以及伪类选择器的个数之和（b），计算选择符中标签选择器和伪元素选择器的个数之和（c）。按 a、b、c 的顺序依次比较大小，大的则优先级高，相等则比较下一个。若最后两个的选择符中 a、b、c 都相等，则按照"就近原则"来判断。
```
<!-- color 为 red -->
<div id="con-id">
    <span class="con-span"></span>
</div>

#con-id span {
    color: red;
}
div .con-span {
    color: blue;
}
```

>+ 5.属性后插有 !important 的属性拥有最高优先级。若同时插有 !important，则再利用规则 3、4 判断优先级
```
<!-- background 为 red -->
<div class="father">
    <p class="son"></p>
</div>

p {
    background: red !important;
}
.father .son {
    background: blue;
}
```

43. flex的特点？为什么要用它？
>flex的特点
>+ 可以在垂直或者水平方向以任意一种对齐方式进行样式布局
>+ 可以在单一轴线上布局也可以在多行内布局
>+ 随可用空间的变化进行响应式布局（能够调整其子元素的宽度或者高度以使其能在不同分辨率的屏幕下能用最好的方式去填充可用空间）  

>传统的布局方案主要基于CSS盒子模型，依赖Display、Position、Float等属性。但是它对于一些特殊布局非常不方便，比如水平垂直居中。flex布局很容易实现水平垂直居中

44. 重绘(repaint)和重排(reflow)
>[重绘和重排](https://juejin.im/post/6844903745914929165)  
>"重绘"不一定会出现"重排"，"重排"必然会出现"重绘"

>重排(回流):任何会改变元素几何信息(元素的位置和尺寸大小)的操作，都会触发重排  
>重绘:当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。

45. 用一行代码清楚一串字符串最前面和最后面的空格（中间也有空格）
```
//清空前后的空格
let str = ' sim on '
console.log(str.trim()) //sim on

//清除两边以及中间的空格
let str = ' sim on '
console.log(str.trim().split(' ').join('')) //simon
```

46. http传输中body的格式有哪些，具体说一下
>multipart/form-data:表单的格式提交数据。主要用来上传文件。

>application/x-www-form-urlencoded:以键值对的格式提交数据。例如我们表单提交数据。  

>raw
>+ 选择text，则请求头是： text/plain
>+ 选择javascript，则请求头是： application/javascript
>+ 选择json，则请求头是： application/json
>+ 选择application/xml，则请求头是： application/xml

>Binary:上传二进制文件

47. base64格式的输入和输出
