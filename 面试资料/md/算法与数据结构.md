15. 手写前序遍历二叉树
>[前序遍历二叉树](https://www.php.cn/js-tutorial-407488.html)
```
function BinarySearchTree () {

    //创建二叉树类
    var Node = function(key) {
        this.key = key
        this.left = null
        this.right = null
    }
    var root = null

    //插入节点
    this.insert = function(key) {
        var newNode = new Node(key)
        if(root === null) {
            root = newNode
        } else {
            insertNode(root, newNode)
        }
    }

    var insertNode = function(node, newNode) {
        if (newNode.key <= node.key) {
            if (node.left === null) {
                node.left = newNode
            }else {
                insertNode(node.left, newNode)
            }
        }else {
            if (node.right === null) {
                node.right = newNode
            }else {
                insertNode(node.right, newNode)
            }
        }
    }

    //实现中序遍历
    this.inOrderTraverse = function() {
        inOrderTraverseNode(root)
    }
    var inOrderTraverseNode = function(node) {
        if (node !== null) {
            inOrderTraverseNode(node.left)
            console.log(node.key)
            inOrderTraverseNode(node.right)
        }
    }

    // 实现先序遍历
    this.preOrderTraverse = function() {
        preOrderTraverseNode(root)
    }
    var preOrderTraverseNode = function(node) {
        if (node !== null) {
            console.log(node.key)
            preOrderTraverseNode(node.left)
            preOrderTraverseNode(node.right)
        }
    }

    // 实现后序遍历
    this.postOrderTraverse = function() {
        postOrderTraverseNode(root)
    }
    var postOrderTraverseNode = function(node) {
        if (node !== null) {
            postOrderTraverseNode(node.left)
            postOrderTraverseNode(node.right)
            console.log(node.key)
        }
    }
}

var arr = [9,6,3,8,12,15]
var tree = new BinarySearchTree()
arr.map(item => {tree.insert(item)})

console.log("中序遍历")
tree.inOrderTraverse()
console.log("前序遍历")
tree.preOrderTraverse()
console.log("后序遍历")
tree.postOrderTraverse()

```

16. 手写快速排序
```
var quicksort = function(arr){
    if(!arr instanceof Array || arr.length <=1 ){
        return arr
    }

    let pivotIndex = Math.floor(arr.length / 2)
    let pivot = arr.splice(pivotIndex,1)[0]

    let left = []
    let right = []
    for(let i = 0;i < arr.length;i++){
        if(arr[i] < pivot){
            left.push(arr[i])
        }else{
            right.push(arr[i])
        }
    }
    return quicksort(left).concat([pivot],quicksort(right))
}

var array = [8,7,0,7,5,2,5,3,1]
quicksort(array)
```

30. 栈和队列的区别？如何用两个栈实现一个队列？
>栈遵循“后进先出（LIFO）”的原则，即只能在该线性表的一头进行数据的插入和删除，该位置称为“栈顶”,而另外一头称为“栈底”;  
>队列遵循“先进先出（FIFO）”的原则，即只能在队列的尾部插入元素，头部删除元素。

```
//实现思路：假设两个栈分别为 stack1 和 stack2，将stack1用于入队操作，将stack2用于出队操作。当stack2为空时，将stack1的元素弹出并推入stack2中。每次出队操作，就是对stack2的弹出操作。

let stack1 = [],stack2 = []

function add(node){
    stack1.push(node)
}

function remove(){
    if(stack1.length == 0 && stack2.length == 0) reutrn 

    if(stack2.length == 0){
        for(let i = stack1.length - 1; i>=0; i--){
            stack2.push(stack1.pop())
        }
    }
    return stack2.pop()
}
```

36. 手写dfs、bfs算法，概述用递归实现bfs、循环实现dfs。 
>[深度优先遍历(DFS)和广度优先遍历(BFS)](https://www.php.cn/js-tutorial-416671.html)   
>DFS(深度优先搜索):以纵向的维度对dom树进行遍历，从一个dom节点开始，一直遍历其子节点，直到它的所有子节点都被遍历完毕之后在遍历它的兄弟节点。   
>BFS(广度优先搜索):以横向的维度对dom树进行遍历，从该节点的第一个子节点开始，遍历其所有的兄弟节点，再遍历第一个节点的子节点，完成该遍历之后，暂时不深入，开始遍历其兄弟节点的子节点。  

![DFS](https://s1.ax1x.com/2020/10/27/BQumRS.png)
```
//深度优先搜索(DFS)
function deepFirstSearch(node,nodeList) { 
    if (node) {   
        nodeList.push(node)
        var children = node.children  
        for (var i = 0; i < children.length; i++)
        //每次递归的时候将 需要遍历的节点 和 节点所存储的数组传下去
        deepFirstSearch(children[i],nodeList);  
    }   
    return nodeList
}
```
![BFS](https://s1.ax1x.com/2020/10/27/BQunxg.png)
```
//广度优先搜索(BFS)
//递归版本的BFS由于层级太深，会导致堆栈溢出：Maximum call stack size exceeded，但遍历的顺序依旧没有问题，可以在遍历过程中进行操作，不返回遍历数组即可。
function breadthFirstSearch(node) {
    var nodes = []
    var i = 0
    if (!(node == null)) {
        nodes.push(node)
        breadthFirstSearch(node.nextElementSibling)
        node = nodes[i++]
        breadthFirstSearch(node.firstElementChild)
    }
    return nodes
}
```