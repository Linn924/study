<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /*
            从声明过程、内存分配和变量提升来分析

            声明过程：
                var：遇到有var的作用域，在任何语句执行前都已经完成了声明和初始化，也就是变量提升而且拿到
                    undefined的原因
                function：声明、初始化、赋值一开始就全部完成，所以函数的变量提升优先级更高
                let：解析器进入一个块级作用域，发现let关键字，变量只是先完成声明，并没有到初始化那一步。
                    此时如果在此作用域提前访问，则报错xx is not defined，这就是暂时性死区的由来。等到
                    解析到有let那一行的时候，才会进入初始化阶段。如果let的那一行是复制操作，则初始化和
                    赋值同时进行
                const、class都是同let一样的道理

                {
                    console.log(a)
                    let a = 1
                }

                发现作用域内有let a ，先注册个a，仅仅注册
                a is not defined 暂时性死区的表现
                a 赋值为 1

                对比于var，let和const知识解耦了声明和初始化的过程

            内存分配：
                var：直接在栈内存中预分配内存空间，然后等到时机代码行执行时，再存储对应的变量，如果传的
                    是引用类型，那么会在堆内存中开辟一个内存空间存储实际内容，栈内存会存储一个纸箱堆内存的指针
                let：不会在栈内存中预分配内存空间，而且在栈内存分配变量时，做一个检查，如果有相同变量名存在就会
                    报错
                const：不会在栈内存中预分配内存空间，在栈内存分配变量时也会做同样的检查。不过const存储的变量是、
                    不可修改的，对基本数据类型来说无法修改定义的值，对引用数据类型来说无法修改栈内存里分配的指针，
                    但可以修改指针指向的对象里面的属性
            
            变量提升：let const var 三者其实都会存在变量提升
                var：声明和初始化过程都提升了，所以在赋值前访问到的undefined
                let和const：声明过程提升了，初始化过程并没有提升，所以会产生暂时性死区
                function的创建、初始化、赋值都被提升了
        */
    </script>
</body>
</html>