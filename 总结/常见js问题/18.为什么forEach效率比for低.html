<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /*
            arr.forEach(callback(currentValue [, index [, array]])[, thisArg])
            for(let i = 0; i < n; i++){}

            .net 1.1 之前的对值类型的装箱，一个是每次调用GetEnumator方法的函数调用带来的时间消耗，单一
            次都不消耗时间，但经过大量循环放大后，时间消耗比较明显
            .net 1.1 之后的版本，forEach对值类型已经不装箱，不慢了，因为有了yelid关键字

            函数调用带来的堆栈创建内存分配则不可避免

            绝对意义上，for比forEach快，但从.net 1.1 之后，这个差距缩小到多一层函数调用而已，不是特别严格
            的地方，还是用forEach好一点。因为forEach不止可以访问一个数组或者List这样循环时能确定长度的集合，
            也可以访问可迭代的类型，因为不需要再循环开始之前就准备好要循环的数据，而是每次forEach循环获取下一个数据

        */
    </script>
</body>
</html>